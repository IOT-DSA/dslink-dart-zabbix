library dslink.zabbix.nodes.zabbix_event;

import 'dart:async';
import 'dart:collection' show HashMap;

import 'package:dslink/dslink.dart';
import 'package:dslink/utils.dart';

import 'client.dart';
import 'common.dart';

//* @Node
//* @MetaType ZabbixEvent
//* @Is zabbixEventNode
//* @Parent Events
//*
//* Events generated by the parent ZabbixTrigger
//*
//* A ZabbixEvent is generated by a Trigger conditions being met. The path and
//* name for the event is the eventId.
class ZabbixEvent extends ZabbixChild {
  static const String isType = 'zabbixEventNode';

  static final HashMap<String, ZabbixEvent> _cache =
  new HashMap<String, ZabbixEvent>();

  static ZabbixEvent getById(String id) => _cache[id];

  static const _values = const {
    '0' : const { '0' : 'Ok', '1' : 'Problem'},
    '1' : const {
      '0' : 'host or service up',
      '1' : 'host or service down',
      '2' : 'host or service discovered',
      '3' : 'host or service lost'
    },
    '3' : const { '0' : 'normal', '1' : 'Unknown or Not Supported'}
  };
  static const _objects = const {
    '0' : const { '0' : 'Trigger'},
    '1' : const { '1' : 'discovered host', '2' : 'discovered service'},
    '2' : const { '3' : 'auto-registered host'},
    '3' : const { '0' : 'Trigger', '4' : 'Item', '5' : 'LLD rule'}
  };
  static const _sources = const [
    'trigger', 'discovery rule', 'auto-registration', 'internal'];

  static Map<String, dynamic> _acknowledgementDefinition(Map ack) {
    var ackTime = new DateTime.fromMillisecondsSinceEpoch(
        int.parse(ack['clock']) * 1000);

    //* @Node
    //* @MetaType ZabbixAcknowledgement
    //* @Parent Acknowledgements
    //*
    //* Acknowledgement received by the remote server.
    //*
    //* An acknowledgement for the event on the trigger. Path and name are the
    //* acknowledgementId.
    return {
      //* @Node userid
      //* @Parent ZabbixAcknowledgement
      //*
      //* User who acknowledged the event. Display name is User ID. The value
      //* is the user's Id.
      //* @Value string
      'userid' : {
        r'$name' : 'User ID',
        r'$type' : 'string',
        r'?value' : ack['userid'],
        //* @Node alias
        //* @Is zabbixValueNode
        //* @Parent userid
        //*
        //* Alias for the user.
        //* @Value string
        'alias' : ZabbixValue.definition('Alias', 'string', ack['alias'],
            false),
        //* @Node name
        //* @MetaType ackUserName
        //* @Is zabbixValueNode
        //* @Parent userid
        //*
        //* The user's first name.
        //* @Value string
        'name' : ZabbixValue.definition('Name', 'string', ack['name'], false),
        //* @Node surname
        //* @MetaType ackUserSurname
        //* @Is zabbixValueNode
        //* @Parent userid
        //*
        //* The user's surname (last name).
        //* @Value string
        'surname' : ZabbixValue.definition('Surname', 'string',
            ack['surname'], false)
      },
      //* @Node clock
      //* @Is zabbixValueNode
      //* @Parent ZabbixAcknowledgement
      //*
      //* Timestamp of the acknowledged time.
      //* @Value string
      'clock' : ZabbixValue.definition('Acknowledged Time', 'string',
          ackTime.toIso8601String(), false),
      //* @Node message
      //* @MetaType ackMessage
      //* @Is zabbixNodeValue
      //* @Parent ZabbixAcknowledgement
      //*
      //* Message which accompanies the acknowledgement.
      //* @Value string
      'message' : ZabbixValue.definition('Message', 'string', ack['message'],
          false)
    };
  }

  static Map<String, dynamic> definition(Map event) {
    var source = _sources[int.parse(event['source'])];
    var time = new DateTime.fromMillisecondsSinceEpoch(
        int.parse(event['clock']) * 1000);
    var relatedObject = _objects[event['source']][event['object']];
    var eventValue = _values[event['source']][event['value']];

    var acknowledgements = {};
    for (Map ack in event['acknowledges']) {
      acknowledgements[ack['acknowledgeid']] = _acknowledgementDefinition(ack);
    }

    var ret = {
      r'$is' : isType,
      //* @Node eventid
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Id of the event
      //*
      //* @Value string
      'eventid' : ZabbixValue.definition('Event ID', 'string', event['eventid'],
          false),
      //* @Node acknowledged
      //* @Parent ZabbixEvent
      //*
      //* Total number of acknowledgements on this event.
      //*
      //* @Value number
      'acknowledged' : {
        r'$name' : 'Acknowledged',
        r'$type' : 'number',
        r'?value' : int.parse(event['acknowledged']),
        //* @Node Acknowledgements
        //* @Parent acknowledged
        //*
        //* Collection of Acknowledgements on this trigger.
        'Acknowledgements' : acknowledgements
      },
      //* @Node clock
      //* @MetaType eventClock
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Timestamp of when the event was created.
      //*
      //* @Value string
      'clock' : ZabbixValue.definition(
          'Created', 'string', time.toIso8601String(),
          false),
      //* @Node ns
      //* @MetaType eventNs
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Nanosecond timestamp of when the event was created.
      //*
      //* @Value string
      'ns' : ZabbixValue.definition('Created (nanoseconds)', 'string',
          event['ns'], false),
      //* @Node object
      //* @MetaType eventObject
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Type of object related to this event.
      //*
      //* String representation of the type of object for this event.
      //* The value will vary depending on the event type.
      //*
      //* @Value string
      'object' : ZabbixValue.definition('Object type', 'string', relatedObject,
          false),
      //* @Node objectid
      //* @MetaType eventObjId
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Id of the object related to this event.
      //*
      //* @Value string
      'objectid' : ZabbixValue.definition('Object ID', 'string',
          event['objectid'], false),
      //* @Node source
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* The type of event.
      //*
      //* @Value string
      'source' : ZabbixValue.definition('Type', 'string', source, false),
      //* @Node value
      //* @MetaType eventValue
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* State of the related object.
      //*
      //* The value of the event is the string representation of the status of
      //* the object related to the event. This will vary depending on the type
      //* of event generated.
      //*
      //* @Value string
      'value' : ZabbixValue.definition('Value', 'string', eventValue, false),
      AcknowledgeEvent.pathName : AcknowledgeEvent.definition()
    };

    if (event['value_changed'] != null) {
      //* @Node value_changed
      //* @Is zabbixValueNode
      //* @Parent ZabbixEvent
      //*
      //* Value changed is the number of times the event's value has updated.
      //*
      //* @Value number
      ret['value_changed'] = ZabbixValue.definition('Value Changed', 'number',
          event['value_changed'], false);
    }
    return ret;
  }

  ZabbixEvent(String path) : super(path);

  @override
  void onCreated() {
    _cache.putIfAbsent(name, () => this);
  }

  bool updateChild(String path, String valueName, newValue, oldValue) => true;

  void update(Map updatedValues) {
    updateAcknowledges(List<Map> acks) {
      var acksNd = provider.getOrCreateNode('$path/acknowledged/Acknowledgements');

      for (Map ack in acks) {
        var aNode = provider.getNode('${acksNd.path}/${ack['acknowledgeid']}');
        if (aNode == null) {
          provider.addNode('${acksNd.path}/${ack['acknowledgeid']}',
              _acknowledgementDefinition(ack));
          continue;
        }

        var ackTime = new DateTime.fromMillisecondsSinceEpoch(
            int.parse(ack['clock']) * 1000);
        for (var key in ack.keys) {
          LocalNode nd;
          var newVal;
          switch (key) {
            case 'alias':
            case 'name':
            case 'surname':
              nd = provider.getNode('${aNode.path}/userid/$key');
              newVal = ack[key];
              break;
            case 'clock':
              newVal = ackTime.toIso8601String();
              break;
            default:
              nd = provider.getNode('${aNode.path}/$key');
              newVal = ack[key];
          }

          nd.updateValue(newVal);
        }
      }
    }

    var source = _sources[int.parse(updatedValues['source'])];
    var clock = new DateTime.fromMillisecondsSinceEpoch(
        int.parse(updatedValues['clock']) * 1000);
    var relatedObject = _objects[updatedValues['source']][updatedValues['object']];
    var eventValue = _values[updatedValues['source']][updatedValues['value']];

    for (var key in updatedValues.keys) {
      var nd = provider.getNode('$path/$key');
      var newVal;
      switch (key) {
        case 'acknowledges':
          updateAcknowledges(updatedValues[key]);
          continue;
        case 'clock':
          newVal = clock.toIso8601String();
          break;
        case 'object':
          newVal = relatedObject;
          break;
        case 'source':
          newVal = source;
          break;
        case 'value':
          newVal = eventValue;
          break;
        default:
          newVal = updatedValues[key];
      }

      if (nd == null && key == 'value_changed') {
        provider.addNode('$path/$key', ZabbixValue.definition('Value Changed',
            'number', num.parse(updatedValues[key]), false));
      }
      nd?.updateValue(newVal);
    }
  }
}

//* @Action Acknowledge_Event
//* @Is zabbixAcknowledgeEvent
//* @Parent ZabbixEvent
//*
//* Send an acknowledgement of the event to the remote server.
//*
//* Acknowledge Event will acknowledge the event with the remote server. If
//* successful, the acknowledgement will be added to the events acknowledgements.
//* Action will fail if message parameter is not specified.
//*
//* @Param message string Message to include with the acknowledgement.
//*
//* @Return value
//* @Column success bool Success will return true on success; False on failure.
//* @Column resultMessage string Result message will be Success if the action
//* completes successfully. Otherwise it will provide an error message.
class AcknowledgeEvent extends SimpleNode {
  static const String isType = 'zabbixAcknowledgeEvent';
  static const String pathName = 'Acknowledge_Event';
  static Map<String, dynamic> definition() => {
    r'$is' : isType,
    r'$name' : 'Acknowledge Event',
    r'$invokable' : 'write',
    r'$params' : [
      {
        'name' : 'message',
        'type' : 'string',
        'placeholder' : 'Acknowledgement Message'
      }
    ],
    r'$columns' : [
      {
        'name' : 'success',
        'type' : 'bool',
        'default' : false
      },
      {
        'name' : 'resultMessage',
        'type' : 'string',
        'default': ''
      }
    ]
  };

  AcknowledgeEvent(String path) : super(path);

  @override
  Future<Map<String, dynamic>> onInvoke(Map<String, dynamic> params) async {
    var ret = { 'success' : false, 'resultMessage' : '' };
    if (params['message'] == null || params['message'].trim().isEmpty) {
      ret['resultMessage'] = 'AcknowledgementMessage is required.';
      return ret;
    }

    var p = parent as ZabbixEvent;
    var client = await p.client;
    var args = {
      'eventids' : p.name,
      'message' : params['message']
    };

    var result = await client.makeRequest(RequestMethod.eventAcknowledge, args);
    if (result.containsKey('error')) {
      logger.warning('Error deleting Hostgroup: ${result['error']}');
      ret['resultMessage'] = result['error']['data'];
    } else {
      ret['success'] = true;
      ret['resultMessage'] = 'Success';
    }

    return ret;
  }
}
